<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.5">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="AFBA" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">2</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">100</stringProp>
        <stringProp name="ThreadGroup.ramp_time">20</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <com.tag.jmeter.ext.config.PropertyReader guiclass="TestBeanGUI" testclass="com.tag.jmeter.ext.config.PropertyReader" testname="Property File Reader" enabled="true">
          <stringProp name="propFilePath">AFBA_QA.properties</stringProp>
        </com.tag.jmeter.ext.config.PropertyReader>
        <hashTree/>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="checkQuery"></stringProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="connectionProperties"></stringProp>
          <stringProp name="dataSource">AFBADatabase</stringProp>
          <stringProp name="dbUrl">jdbc:sqlserver://;serverName=${__P(serverName)};databaseName=${__P(databaseName)};encrypt=true;trustServerCertificate=true</stringProp>
          <stringProp name="driver">com.microsoft.sqlserver.jdbc.SQLServerDriver</stringProp>
          <stringProp name="initQuery"></stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="password">${__P(password)}</stringProp>
          <stringProp name="poolMax">0</stringProp>
          <boolProp name="preinit">false</boolProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <stringProp name="username">${__P(userName)}</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="Authorization" elementType="Header">
              <stringProp name="Header.name">Authorization</stringProp>
              <stringProp name="Header.value">Bearer ${accessToken}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler Reading file Names" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">false</stringProp>
          <stringProp name="script">import org.apache.commons.io.FilenameUtils;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

// 1. Read the input file and save its location path in a variable
String inputFolderPath = &quot;${__P(inputLocation)}&quot;;
File inputFolder = new File(inputFolderPath);

// 2. Read the output file and save it in xlsxFiles variable
String outputFolderPath = &quot;${__P(outputLocation)}&quot;;
String targetSubfolder = &quot;SFTPResults&quot;;

File outputFolder = new File(outputFolderPath);
File[] outputFiles = outputFolder.listFiles();

List&lt;String&gt; xlsxFiles = new ArrayList&lt;&gt;();
List&lt;String&gt; inputFilePaths = new ArrayList&lt;&gt;();
List&lt;String&gt; inputFileNames = new ArrayList&lt;&gt;();

// Iterate through subfolders
for (File subfolder : outputFiles) {
    if (subfolder.isDirectory() &amp;&amp; subfolder.getName().equals(targetSubfolder)) {
        File[] subfolderFiles = subfolder.listFiles();

        // Iterate through files in the target subfolder
        for (File file : subfolderFiles) {
            String extension = FilenameUtils.getExtension(file.getName());
            if (file.isFile() &amp;&amp; &quot;xlsx&quot;.equals(extension)) {
                xlsxFiles.add(file.getName());
            }
        }
    }
}

// Add XML and CSV files from input folder to the lists
File[] inputFiles = inputFolder.listFiles();
for (File file : inputFiles) {
    String extension = FilenameUtils.getExtension(file.getName());
    if (file.isFile() &amp;&amp; (&quot;xlsx&quot;.equals(extension) || &quot;xml&quot;.equals(extension) || &quot;csv&quot;.equals(extension))) {
        inputFilePaths.add(file.getAbsolutePath());
        inputFileNames.add(file.getName());
    }
}

// Store the list of Excel file names in a variable
vars.putObject(&quot;xlsxFiles&quot;, xlsxFiles);

// Store the count of input files
vars.put(&quot;filesCount&quot;, String.valueOf(inputFileNames.size()));

// Store the input file paths
vars.putObject(&quot;inputFilePaths&quot;, inputFilePaths);

// Store the input file names
vars.putObject(&quot;inputFileNames&quot;, inputFileNames);

// Log all variables for debugging
log.info(&quot;xlsxFiles: {}&quot;, xlsxFiles);
log.info(&quot;filesCount: {}&quot;, inputFileNames.size());
log.info(&quot;inputFilePaths: {}&quot;, inputFilePaths);
log.info(&quot;inputFileNames: {}&quot;, inputFileNames);

</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Authentication" enabled="true">
          <stringProp name="TestPlan.comments">Endpoints for generating and validating authentication token.</stringProp>
        </GenericController>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value"></stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Worksite token call" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;clientCredentials&quot;: &quot;${__P(clientCredentials)}&quot;,&#xd;
    &quot;username&quot;: &quot;${__P(username)}&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${__P(server)}</stringProp>
            <stringProp name="HTTPSampler.port">${__P(port)}</stringProp>
            <stringProp name="HTTPSampler.protocol">${__P(protocol)}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">worksite/token</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="TestPlan.comments">Generate authentication token by passing username and client credentials</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="accessToken" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">accessToken</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">$..accessToken</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
              <stringProp name="JSONPostProcessor.defaultValues">TokenNotFound</stringProp>
            </JSONPostProcessor>
            <hashTree/>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Health" enabled="true">
          <stringProp name="TestPlan.comments">Application Health Check</stringProp>
        </GenericController>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${accessToken}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Health" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${__P(server)}</stringProp>
            <stringProp name="HTTPSampler.port">${__P(port)}</stringProp>
            <stringProp name="HTTPSampler.protocol">${__P(protocol)}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">worksite/health</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="TestPlan.comments">Application Health Check</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="1678703978">Application is healthy!</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
            </ResponseAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="LoopControllerExecutingTestsForAllFiles" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">${filesCount}</stringProp>
        </LoopController>
        <hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler Getting files Names" enabled="true">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">false</stringProp>
            <stringProp name="script">ArrayList outputFileNames = vars.getObject(&quot;xlsxFiles&quot;);
ArrayList inputFilePaths = vars.getObject(&quot;inputFilePaths&quot;);
ArrayList inputFileNames = vars.getObject(&quot;inputFileNames&quot;);

def idx = Integer.parseInt(vars.get(&quot;__jm__LoopControllerExecutingTestsForAllFiles__idx&quot;))

def inputFileNameWithExtension = inputFileNames.get(idx).toString()
def inputFilePath = inputFilePaths.get(idx).toString()

// Extract file name without extension from inputFileName
def inputFileNameWithoutExtension = inputFileNameWithExtension.take(inputFileNameWithExtension.lastIndexOf(&apos;.&apos;))

// Iterate through all output file names to find the matching one based on the input file name (excluding &quot;_Output&quot;)
def matchingOutputFile = null
for (file in outputFileNames) {
    def outputFileWithoutExtension = file.toString().take(file.toString().lastIndexOf(&apos;.&apos;))
    if (outputFileWithoutExtension.equals(inputFileNameWithoutExtension)) {
        matchingOutputFile = file.toString()
        break
    }
}

// If a matching output file is found, use its name; otherwise, use a default name
def finalOutputFileName = matchingOutputFile ?: (inputFileNameWithExtension.take(inputFileNameWithExtension.lastIndexOf(&apos;.&apos;)) + &quot;_Output.xlsx&quot;)

vars.put(&quot;outputFileName&quot;, finalOutputFileName);
vars.put(&quot;inputFileName&quot;, inputFileNameWithExtension);
vars.put(&quot;inputFilePath&quot;, inputFilePath);

log.info(&quot;=======================Files names=============================&quot;);
log.info(finalOutputFileName);
log.info(inputFileNameWithExtension);
log.info(inputFilePath);



</stringProp>
          </JSR223Sampler>
          <hashTree/>
          <org.apache.jmeter.protocol.ssh.sampler.SSHSFTPSampler guiclass="TestBeanGUI" testclass="org.apache.jmeter.protocol.ssh.sampler.SSHSFTPSampler" testname="Upload valid input to SFTP server, File Name: ${inputFileName}" enabled="false">
            <stringProp name="action">put</stringProp>
            <intProp name="connectionTimeout">5000</intProp>
            <stringProp name="destination">${__P(destinationD)}</stringProp>
            <stringProp name="hostname">${__P(sftpHost)}</stringProp>
            <stringProp name="passphrase"></stringProp>
            <stringProp name="password">${__P(sftpPassword)}</stringProp>
            <stringProp name="port">${__P(sftpport)}</stringProp>
            <boolProp name="printFile">true</boolProp>
            <stringProp name="source">${inputFilePath}</stringProp>
            <stringProp name="sshkeyfile"></stringProp>
            <stringProp name="username">${__P(sftpUser)}</stringProp>
          </org.apache.jmeter.protocol.ssh.sampler.SSHSFTPSampler>
          <hashTree>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
              <stringProp name="ConstantTimer.delay">5000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Enrollment Process Endpoint Call" enabled="true"/>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="Authorization" elementType="Header">
                  <stringProp name="Header.name">Authorization</stringProp>
                  <stringProp name="Header.value">Bearer ${accessToken}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Enrollment Process Endpoint Call ${inputFileName}" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${__P(server)}</stringProp>
              <stringProp name="HTTPSampler.port">${__P(port)}</stringProp>
              <stringProp name="HTTPSampler.protocol">${__P(protocol)}</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/worksite/enrollment-process</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="TestPlan.comments">Enrollment Process Endpoint Call</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="49586">200</stringProp>
                </collectionProp>
                <stringProp name="Assertion.custom_message"></stringProp>
                <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">2</intProp>
              </ResponseAssertion>
              <hashTree/>
            </hashTree>
          </hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from ENROLLMENT FILE, File Name: ${inputFileName}" enabled="true">
            <stringProp name="dataSource">AFBADatabase</stringProp>
            <stringProp name="query">SELECT TOP (1) FILE_ID, DOCUMENT_ID, STATUS, FAILURE_REASON FROM ENROLLMENT_FILE WHERE FILE_NAME = &apos;${inputFileName}&apos; ORDER BY FILE_ID DESC</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames">FILE_ID, DOCUMENT_ID, FILE_STATUS, FILE_FAILURE_REASON</stringProp>
          </JDBCSampler>
          <hashTree>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion STATUS, FAILURE_REASON Enrollment_File" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Enrollment&quot; sheet
    def enrollmentSheet = workbook.getSheet(&quot;Enrollment_File&quot;)
    if (enrollmentSheet != null) {
        log.info(&quot;Processing data from sheet: Enrollment_File&quot;)
        processSheet(enrollmentSheet, assertionList)
    } else {
        log.info(&quot;Sheet Enrollment_File not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume STATUS and FAILURE_REASON columns exist
    def statusColumnIndex = headers.indexOf(&quot;STATUS&quot;)
    def failureReasonColumnIndex = headers.indexOf(&quot;FAILURE_REASON&quot;)

    // Process each row dynamically
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)

        // Adjust expected statuses and failure reasons dynamically
        def expectedStatus = vars.get(&quot;FILE_STATUS_${rowIndex}&quot;)
        def expectedFailureReason = vars.get(&quot;FILE_FAILURE_REASON_${rowIndex}&quot;)

        def enrollmentStatusCell = row.getCell(statusColumnIndex)
        def enrollmentFailureReasonCell = row.getCell(failureReasonColumnIndex)

        // Handle null values or empty strings in Excel sheet
        def enrollmentStatus = enrollmentStatusCell?.getStringCellValue()?.trim()
        def enrollmentFailureReason = enrollmentFailureReasonCell?.getStringCellValue()?.trim()

        // Treat both null values and empty strings as equivalent
        if (enrollmentStatus == &quot;null&quot; || enrollmentStatus.isEmpty()) {
            enrollmentStatus = null
        }
        if (enrollmentFailureReason == &quot;null&quot; || enrollmentFailureReason.isEmpty()) {
            enrollmentFailureReason = null
        }

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: Enrollment_File Status from Excel: ${enrollmentStatus}, Expected: ${expectedStatus}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Enrollment_File Failure Reason from Excel: ${enrollmentFailureReason}, Expected: ${expectedFailureReason}&quot;)

        // Check if values do not match expected values
        if ((enrollmentStatus != expectedStatus) &amp;&amp; (enrollmentStatus != null || expectedStatus != null)) {
            assertionList.add(&quot;Enrollment_File Status in row ${rowIndex + 1} does not match expected value: $enrollmentStatus&quot;)
        }

        if ((enrollmentFailureReason != expectedFailureReason) &amp;&amp; (enrollmentFailureReason != null || expectedFailureReason != null)) {
            assertionList.add(&quot;Enrollment_File Failure Reason in row ${rowIndex + 1} does not match expected value: $enrollmentFailureReason&quot;)
        }
    }
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
              <stringProp name="ConstantTimer.delay">5000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from ENROLLMENT, File Name: ${inputFileName}" enabled="true">
            <stringProp name="dataSource">AFBADatabase</stringProp>
            <stringProp name="query">SELECT ENROLLMENT_ID, STATUS, FAILURE_REASON, LIFEPRO_MAPPINGS, POLICY_NUMBER FROM ENROLLMENT WHERE FILE_ID = &apos;${FILE_ID_1}&apos;</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames">ENROLLMENT_ID,STATUS, FAILURE_REASON, LIFEPRO_MAPPINGS, POLICY_NUMBER</stringProp>
          </JDBCSampler>
          <hashTree>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion STATUS, FAILURE_REASON Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Enrollment&quot; sheet
    def enrollmentSheet = workbook.getSheet(&quot;Enrollment&quot;)
    if (enrollmentSheet != null) {
        log.info(&quot;Processing data from sheet: Enrollment&quot;)
        processSheet(enrollmentSheet, assertionList)
    } else {
        log.info(&quot;Sheet Enrollment not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume STATUS and FAILURE_REASON columns exist
    def statusColumnIndex = headers.indexOf(&quot;STATUS&quot;)
    def failureReasonColumnIndex = headers.indexOf(&quot;FAILURE_REASON&quot;)

    // Process each row dynamically
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)

        // Adjust expected statuses and failure reasons dynamically
        def expectedStatus = vars.get(&quot;STATUS_${rowIndex}&quot;)
        def expectedFailureReason = vars.get(&quot;FAILURE_REASON_${rowIndex}&quot;)

        def enrollmentStatusCell = row.getCell(statusColumnIndex)
        def enrollmentFailureReasonCell = row.getCell(failureReasonColumnIndex)

        // Handle null values or empty strings in Excel sheet
        def enrollmentStatus = enrollmentStatusCell?.getStringCellValue()?.trim() ?: &quot;&quot;
        def enrollmentFailureReason = enrollmentFailureReasonCell?.getStringCellValue()?.trim() ?: &quot;&quot;

        // Treat both null values and empty strings as equivalent
        if (enrollmentFailureReason == &quot;null&quot; || enrollmentFailureReason.isEmpty()) {
            enrollmentFailureReason = null
        }

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: Enrollment Status from Excel: ${enrollmentStatus}, Expected: ${expectedStatus}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Enrollment Failure Reason from Excel: ${enrollmentFailureReason}, Expected: ${expectedFailureReason}&quot;)

        // Check if values do not match expected values
        if (enrollmentStatus != expectedStatus) {
            assertionList.add(&quot;Enrollment Status in row ${rowIndex + 1} does not match expected value: $enrollmentStatus&quot;)
        }

        if (enrollmentFailureReason != expectedFailureReason) {
            assertionList.add(&quot;Enrollment Failure Reason in row ${rowIndex + 1} does not match expected value: $enrollmentFailureReason&quot;)
        }
    }
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;newBusinessRequest&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
    &quot;CompanyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CompanyCode,
    &quot;ActionFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ActionFlag,
    &quot;GeneratePages&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GeneratePages,
    &quot;ActIssDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ActIssDate,
    &quot;RecvdDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.RecvdDate,
    &quot;SignedDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SignedDate,
    &quot;IssDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.IssDate,
    &quot;ProductId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ProductId,
    &quot;PremiumPaymentMode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PremiumPaymentMode,
    &quot;FormNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.FormNumber,
    &quot;BillCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.BillCode,
    &quot;BillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.BillDay,
    &quot;PolicyControlId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyControlId,
    &quot;PayInitialPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayInitialPrem,
    &quot;DivOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.DivOption,
    &quot;NfoOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.NfoOption,
    &quot;TaxWithholdingFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxWithholdingFlag,
    &quot;TaxCertificationDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCertificationDate,
    &quot;TaxCertificationCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCertificationCode,
    &quot;TaxCodeOverride&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCodeOverride,
    &quot;TaxQualCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxQualCode,
    &quot;PolicyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyCode,
    &quot;ExchangeCode1035&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ExchangeCode1035,
    &quot;Premium1035&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Premium1035,
    &quot;DbOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.DbOption,
    &quot;ShortTermPd&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ShortTermPd,
    &quot;ShortTermMOrD&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ShortTermMOrD,
    &quot;SourceCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SourceCode,
    &quot;State&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.State,
    &quot;CashWithApp&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CashWithApp,
    &quot;AccountNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AccountNumber,
    &quot;GroupPacNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GroupPacNumber,
    &quot;Beneficiary1Relation&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Beneficiary1Relation,
    &quot;Beneficiary2Relation&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Beneficiary2Relation,
    &quot;FinancialRptInd&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.FinancialRptInd,
    &quot;CommissionOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CommissionOption,
    &quot;AdjBillFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AdjBillFlag,
    &quot;AgentCalcPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AgentCalcPrem,
    &quot;MultiplePremiums&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.MultiplePremiums,
    &quot;GenPreBill&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GenPreBill,
    &quot;SuppressInitBill&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SuppressInitBill,
    &quot;AgeOrDur&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AgeOrDur,
    &quot;AnnuityPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuityPrem,
    &quot;AnnuitySpecialMode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuitySpecialMode,
    &quot;AnnuityForm&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuityForm,
    &quot;ArBillCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ArBillCode,
    &quot;ArBillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ArBillDay,
    &quot;CouponAnnuityFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CouponAnnuityFlag,
    &quot;PurchasePrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PurchasePrem,
    &quot;PurchaseDumpIn&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PurchaseDumpIn,
    &quot;VarNoLapsePeriod&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.VarNoLapsePeriod,
    &quot;InitialPremiumDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InitialPremiumDate,
    &quot;IssueNlgTier&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.IssueNlgTier,
    &quot;RothIraYear&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.RothIraYear,
    &quot;OwnerBusinessFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.OwnerBusinessFlag,
    &quot;ReplenishmentRate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ReplenishmentRate,
    &quot;ProcessingFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ProcessingFlag,
    &quot;ExcessDividendOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ExcessDividendOption,
    &quot;PrimaryPerson&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryPerson,
    &quot;PolicyOwnerUnderwritingClass&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerUnderwritingClass,
    &quot;PolicyOwnerSex&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerSex,
    &quot;ConversionType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ConversionType,
    &quot;LinkedCompanyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedCompanyCode,
    &quot;LinkedPolicy&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedPolicy,
    &quot;LinkedType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedType,
    &quot;LivesCovered&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LivesCovered,
    &quot;SecondBillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SecondBillDay,
    &quot;UnderApprovalDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.UnderApprovalDate
        
    ]

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;BillDayCode: ${dbData[&apos;BillDayCode&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;) // Or any other logic as per your requirement
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest (Zeros Ignored): Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;newBusinessRequest&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;CompanyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CompanyCode,
        &quot;PolicyNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyNumber,
        &quot;ActionFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ActionFlag,
        &quot;GeneratePages&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GeneratePages,
        &quot;ActIssDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ActIssDate,
        &quot;RecvdDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.RecvdDate,
        &quot;SignedDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SignedDate,
        &quot;IssDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.IssDate,
        &quot;ProductId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ProductId,
        &quot;PremiumPaymentMode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PremiumPaymentMode,
        &quot;FormNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.FormNumber,
        &quot;BillCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.BillCode,
        &quot;BillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.BillDay,
        &quot;PolicyControlId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyControlId,
        &quot;PayInitialPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayInitialPrem,
        &quot;DivOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.DivOption,
        &quot;NfoOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.NfoOption,
        &quot;TaxWithholdingFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxWithholdingFlag,
        &quot;TaxCertificationDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCertificationDate,
        &quot;TaxCertificationCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCertificationCode,
        &quot;TaxCodeOverride&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxCodeOverride,
        &quot;TaxQualCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.TaxQualCode,
        &quot;PolicyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyCode,
        &quot;ExchangeCode1035&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ExchangeCode1035,
        &quot;Premium1035&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Premium1035,
        &quot;DbOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.DbOption,
        &quot;ShortTermPd&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ShortTermPd,
        &quot;ShortTermMOrD&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ShortTermMOrD,
        &quot;SourceCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SourceCode,
        &quot;State&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.State,
        &quot;CashWithApp&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CashWithApp,
        &quot;AccountNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AccountNumber,
        &quot;GroupPacNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GroupPacNumber,
        &quot;Beneficiary1Relation&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Beneficiary1Relation,
        &quot;Beneficiary2Relation&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Beneficiary2Relation,
        &quot;FinancialRptInd&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.FinancialRptInd,
        &quot;CommissionOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CommissionOption,
        &quot;AdjBillFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AdjBillFlag,
        &quot;AgentCalcPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AgentCalcPrem,
        &quot;MultiplePremiums&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.MultiplePremiums,
        &quot;GenPreBill&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.GenPreBill,
        &quot;SuppressInitBill&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SuppressInitBill,
        &quot;AgeOrDur&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AgeOrDur,
        &quot;AnnuityPrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuityPrem,
        &quot;AnnuitySpecialMode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuitySpecialMode,
        &quot;AnnuityForm&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.AnnuityForm,
        &quot;ArBillCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ArBillCode,
        &quot;ArBillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ArBillDay,
        &quot;CouponAnnuityFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.CouponAnnuityFlag,
        &quot;PurchasePrem&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PurchasePrem,
        &quot;PurchaseDumpIn&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PurchaseDumpIn,
        &quot;VarNoLapsePeriod&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.VarNoLapsePeriod,
        &quot;InitialPremiumDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InitialPremiumDate,
        &quot;IssueNlgTier&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.IssueNlgTier,
        &quot;RothIraYear&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.RothIraYear,
        &quot;OwnerBusinessFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.OwnerBusinessFlag,
        &quot;ReplenishmentRate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ReplenishmentRate,
        &quot;ProcessingFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ProcessingFlag,
        &quot;ExcessDividendOption&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ExcessDividendOption,
        &quot;PrimaryPerson&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryPerson,
        &quot;PolicyOwnerSex&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerSex,
        &quot;ConversionType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.ConversionType,
        &quot;LinkedCompanyCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedCompanyCode,
        &quot;LinkedPolicy&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedPolicy,
        &quot;LinkedType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LinkedType,
        &quot;LivesCovered&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.LivesCovered,
        &quot;SecondBillDay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.SecondBillDay,
        &quot;UnderApprovalDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.UnderApprovalDate
    ]

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;BillDayCode: ${dbData[&apos;BillDayCode&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;) // Or any other logic as per your requirement
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        if (key == &quot;PolicyNumber&quot;) {
            continue // Skip comparing PolicyNumber
        }
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Remove leading zeros for comparison
        dbValue = dbValue.replaceFirst(&quot;^0*&quot;, &quot;&quot;)
        excelValue = excelValue.replaceFirst(&quot;^0*&quot;, &quot;&quot;)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: policyActivationRequest: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;policyActivationRequest&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;CompanyCode&quot;: databaseJson?.lifeproLogs?.policyActivationRequest?.activatePendingRIPolicyReq?.CompanyCode,
    ]

    log.info(&quot;BillDayCode: ${dbData[&apos;BillDayCode&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, keep it as is
                        excelData.put(column, String.valueOf(numericValue))
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: policyGroupParameterRequest: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;policyGroupParameterRequest&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;CompanyCode&quot;: databaseJson?.lifeproLogs?.policyGroupParameterRequest?.CompanyCode,
        &quot;AllowableValueId&quot;: databaseJson?.lifeproLogs?.policyGroupParameterRequest?.AllowableValueId,
        &quot;ParamValue&quot;: databaseJson?.lifeproLogs?.policyGroupParameterRequest?.ParamValue,
        &quot;ParamDefinitionId&quot;: databaseJson?.lifeproLogs?.policyGroupParameterRequest?.ParamDefinitionId,
    ]

    log.info(&quot;BillDayCode: ${dbData[&apos;BillDayCode&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, keep it as is
                        excelData.put(column, String.valueOf(numericValue))
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Agents: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Agents&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell agentIndexCell = dataRow.getCell(columnIndices.get(&quot;AgentIndex&quot;));
    
    if (seqNoCell == null || agentIndexCell == null) {
        continue; // Skip rows where Seq No or BenIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int agentIndex = (int) agentIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;AgentFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgentFlag,
        &quot;AgtAgentNum&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtAgentNum,
        &quot;AgtMarket&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtMarket,
        &quot;AgentLevel&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgentLevel,
        &quot;AgtCommPct&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtCommPct,
        &quot;AgtProdPct&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtProdPct,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;);
                    break;
                default:
                    excelData.put(column, &quot;null&quot;);
            }
        } else {
            excelData.put(column, &quot;null&quot;);
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, agentIndex ${agentIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, agentIndex ${agentIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Agents (Null handled): Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Agents&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell agentIndexCell = dataRow.getCell(columnIndices.get(&quot;AgentIndex&quot;));
    
    if (seqNoCell == null || agentIndexCell == null) {
        continue; // Skip rows where Seq No or BenIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int agentIndex = (int) agentIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;AgentFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgentFlag,
        &quot;AgtAgentNum&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtAgentNum,
        &quot;AgtMarket&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtMarket,
        &quot;AgentLevel&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgentLevel,
        &quot;AgtCommPct&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtCommPct,
        &quot;AgtProdPct&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Agents?[agentIndex]?.AgtProdPct,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;); // Empty cell
                    break;
                default:
                    excelData.put(column, &quot;&quot;); // Treat other types as empty
            }
        } else {
            excelData.put(column, &quot;&quot;); // Cell is absent, treat as empty string
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;; // Treat null as empty string &quot;&quot;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, agentIndex ${agentIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, agentIndex ${agentIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Benefits: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Benefits&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell benIndexCell = dataRow.getCell(columnIndices.get(&quot;BenIndex&quot;));
    
    if (seqNoCell == null || benIndexCell == null) {
        continue; // Skip rows where Seq No or BenIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int benIndex = (int) benIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;PercentRating&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.PercentRating,
        &quot;PercentDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.PercentDuration,
        &quot;RateUpAge&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.RateUpAge,
        &quot;SecndFlatDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndFlatDuration,
        &quot;SecndTable&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndTable,
        &quot;SecndPercentRating&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndPercentRating,
        &quot;SecndPercentDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndPercentDuration,
        &quot;SecndRateUpAge&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndRateUpAge,
        &quot;OverrideReinsurance&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.OverrideReinsurance,
        &quot;UndrCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.UndrCode,
        &quot;SecndFlatExtra&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndFlatExtra,
        &quot;UndrType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.UndrType,
        &quot;ReinCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.ReinCode,
        &quot;TaxBasisFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.TaxBasisFlag,
        &quot;SubstandardOverlay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SubstandardOverlay,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;);
                    break;
                default:
                    excelData.put(column, &quot;null&quot;);
            }
        } else {
            excelData.put(column, &quot;null&quot;);
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, BenIndex ${benIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, BenIndex ${benIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Benefits (Null handled): Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Benefits&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell benIndexCell = dataRow.getCell(columnIndices.get(&quot;BenIndex&quot;));
    
    if (seqNoCell == null || benIndexCell == null) {
        continue; // Skip rows where Seq No or BenIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int benIndex = (int) benIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;PercentRating&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.PercentRating,
        &quot;PercentDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.PercentDuration,
        &quot;RateUpAge&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.RateUpAge,
        &quot;SecndFlatDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndFlatDuration,
        &quot;SecndTable&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndTable,
        &quot;SecndPercentRating&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndPercentRating,
        &quot;SecndPercentDuration&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndPercentDuration,
        &quot;SecndRateUpAge&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndRateUpAge,
        &quot;OverrideReinsurance&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.OverrideReinsurance,
        &quot;UndrCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.UndrCode,
        &quot;SecndFlatExtra&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SecndFlatExtra,
        &quot;UndrType&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.UndrType,
        &quot;ReinCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.ReinCode,
        &quot;TaxBasisFlag&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.TaxBasisFlag,
        &quot;SubstandardOverlay&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Benefits[benIndex]?.SubstandardOverlay,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;); // Treat blank cells as empty string
                    break;
                default:
                    excelData.put(column, &quot;null&quot;); // Treat other types as null
            }
        } else {
            excelData.put(column, &quot;&quot;); // Treat null cells as empty string
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, BenIndex ${benIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, BenIndex ${benIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:InsurdsName: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;InsurdsName&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell InsurdIndexCell = dataRow.getCell(columnIndices.get(&quot;InsurdIndex&quot;));
    
    if (seqNoCell == null || InsurdIndexCell == null) {
        continue; // Skip rows where Seq No or InsurdIndexCell is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int InsurdIndex = (int) InsurdIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InsurdsName?[InsurdIndex]?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InsurdsName?[InsurdIndex]?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InsurdsName?[InsurdIndex]?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InsurdsName?[InsurdIndex]?.Middle,
        &quot;nameId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.InsurdsName?[InsurdIndex]?.nameId,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;InsurdsName Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;);
                    break;
                default:
                    excelData.put(column, &quot;null&quot;);
            }
        } else {
            excelData.put(column, &quot;null&quot;);
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Insureds: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Insureds&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell InsurdIndexCell = dataRow.getCell(columnIndices.get(&quot;InsurdIndex&quot;));
    
    if (seqNoCell == null || InsurdIndexCell == null) {
        continue; // Skip rows where Seq No or InsurdIndexCell is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int InsurdIndex = (int) InsurdIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;InsSex&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsSex,
        &quot;InsUwcls&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsUwcls,
        &quot;InsRelate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsRelate,
        &quot;InsFeet&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsFeet,
        &quot;InsInches&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsInches,
        &quot;InsWeight&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsWeight,
        &quot;InsPlace&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsPlace,
        &quot;InsInforce&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsInforce,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Insureds Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;);
                    break;
                default:
                    excelData.put(column, &quot;null&quot;);
            }
        } else {
            excelData.put(column, &quot;null&quot;);
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:Insureds (Null handled): Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;Insureds&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and InsurdIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell InsurdIndexCell = dataRow.getCell(columnIndices.get(&quot;InsurdIndex&quot;));
    
    if (seqNoCell == null || InsurdIndexCell == null) {
        continue; // Skip rows where Seq No or InsurdIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int InsurdIndex = (int) InsurdIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;InsSex&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsSex,
        &quot;InsUwcls&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsUwcls,
        &quot;InsRelate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsRelate,
        &quot;InsFeet&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsFeet,
        &quot;InsInches&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsInches,
        &quot;InsWeight&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsWeight,
        &quot;InsPlace&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsPlace,
        &quot;InsInforce&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.Insureds?[InsurdIndex]?.InsInforce,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Insureds Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;); // Treat blank cells as empty string
                    break;
                default:
                    excelData.put(column, &quot;null&quot;); // Treat other types as null
            }
        } else {
            excelData.put(column, &quot;&quot;); // Treat null cells as empty string
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, InsurdIndex ${InsurdIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:PayorName: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;PayorName&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayorName?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayorName?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayorName?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayorName?.Middle,
        &quot;nameId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PayorName?.nameId,
    ]

    log.info(&quot;First: ${dbData[&apos;First&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, keep it as is
                        excelData.put(column, String.valueOf(numericValue))
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:PolicyOwnerName: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;PolicyOwnerName&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.Middle,
        &quot;nameId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.nameId,
        &quot;AddrState&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerName?.AddrState,
    ]

    log.info(&quot;First: ${dbData[&apos;First&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, keep it as is
                        excelData.put(column, String.valueOf(numericValue))
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:PolicyOwnerRelationInfo: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;PolicyOwnerRelationInfo&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;PercentOfInterest&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerRelationInfo?.PercentOfInterest,
        &quot;SubTypeCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PolicyOwnerRelationInfo?.SubTypeCode,
    ]

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Convert numeric value to integer and then to string
                    excelData.put(column, String.valueOf((int) numericValue))
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Extract integer part from dbValue if it&apos;s numeric
        if (dbValue.isNumber()) {
            dbValue = String.valueOf((int) Double.parseDouble(dbValue))
        }

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:EmployeeData: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;EmployeeData&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;EmployeeClass&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.EmployeeClass,
        &quot;EmployeeNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.EmployeeNumber,
        &quot;GroupNumber&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.GroupNumber,
        &quot;HireDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.HireDate,
        &quot;Status&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.Status,
        &quot;StatusDate&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.StatusDate,
    ]

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Convert numeric value to integer and then to string
                    excelData.put(column, String.valueOf((int) numericValue))
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Extract integer part from dbValue if it&apos;s numeric
        if (dbValue.isNumber()) {
            dbValue = String.valueOf((int) Double.parseDouble(dbValue))
        }

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:NewBusinessNames: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = vars.get(&quot;outputFileName&quot;)
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

ZipSecureFile.setMinInflateRatio(0.005)
def file = new File(fullPath)
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;)
    return
}

FileInputStream fileStream = new FileInputStream(file)
XSSFWorkbook workbook = new XSSFWorkbook(fileStream)

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;NewBusinessNames&quot;)
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;)
    workbook.close()
    fileStream.close()
    return
}

def headerRow = sheet.getRow(0)

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;()
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex())
}

def rowCount = sheet.getPhysicalNumberOfRows()

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false
def mismatchMessages = new StringBuilder()

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    // Get the JSON data for the current row
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + rowIndex
    def jsonData = vars.get(jsonDataVar)
    log.info(&quot;Database JSON data for row ${rowIndex}: ${jsonData}&quot;)

    def databaseJson
    try {
        databaseJson = new JsonSlurper().parseText(jsonData)
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;)
        continue // Skip to the next row
    }

    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.NewBusinessNames?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.NewBusinessNames?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.NewBusinessNames?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.NewBusinessNames?.Middle,
        &quot;nameId&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.EmployeeData?.NewBusinessNames?.nameId,
    ]

    log.info(&quot;First: ${dbData[&apos;First&apos;]}&quot;)

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;()
    Row dataRow = sheet.getRow(rowIndex)
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column))
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim())
                    break
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue()
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int)numericValue))
                    } else {
                        // If it has a decimal part, keep it as is
                        excelData.put(column, String.valueOf(numericValue))
                    }
                    break
                default:
                    excelData.put(column, &quot;&quot;)
            }
        } else {
            excelData.put(column, &quot;&quot;)
        }
    }

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;
        def excelValue = excelData.get(key)

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true
            assertionFailed = true
            mismatchMessages.append(&quot;Mismatch found for row ${rowIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;)
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for row ${rowIndex}&quot;)
    }
}

workbook.close()
fileStream.close()

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true)
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;)
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;)
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:PrimaryBeneficiariesName: Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;PrimaryBeneficiariesName&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and BenIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell PrimaryIndexCell = dataRow.getCell(columnIndices.get(&quot;PrimaryIndex&quot;));
    
    if (seqNoCell == null || PrimaryIndexCell == null) {
        continue; // Skip rows where Seq No or PrimaryIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int PrimaryIndex = (int) PrimaryIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.Middle,
        &quot;SubTypeCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.SubTypeCode,
        &quot;PercentOfInterest&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.PercentOfInterest,
        &quot;AmountOfInterest&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.AmountOfInterest,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;);
                    break;
                default:
                    excelData.put(column, &quot;null&quot;);
            }
        } else {
            excelData.put(column, &quot;null&quot;);
        }
    }

    // Remove nameId from dbData and excelData before comparison
    dbData.remove(&quot;nameId&quot;);
    excelData.remove(&quot;nameId&quot;);

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, PrimaryIndex ${PrimaryIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, PrimaryIndex ${PrimaryIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion Lifepro Mappings: newBusinessRequest:PrimaryBeneficiariesName (Null handled): Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import groovy.json.JsonSlurper;
import java.util.Map;
import java.util.HashMap;

def folderPath = &quot;${__P(outputLocation)}&quot;;
def fileName = vars.get(&quot;outputFileName&quot;);
def targetSubfolder = &quot;SFTPResults&quot;;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;;

ZipSecureFile.setMinInflateRatio(0.005);
def file = new File(fullPath);
if (!file.exists()) {
    log.error(&quot;File not found: ${fullPath}&quot;);
    return;
}

FileInputStream fileStream = new FileInputStream(file);
XSSFWorkbook workbook = new XSSFWorkbook(fileStream);

// Check if the LifePro_Mappings sheet exists
def sheet = workbook.getSheet(&quot;PrimaryBeneficiariesName&quot;);
if (sheet == null) {
    log.info(&quot;LifePro_Mappings sheet not found in the Excel file. Passing the assertion.&quot;);
    workbook.close();
    fileStream.close();
    return;
}

def headerRow = sheet.getRow(0);

// Extract the column indices for each required field
Map&lt;String, Integer&gt; columnIndices = new HashMap&lt;&gt;();
for (Cell cell : headerRow) {
    columnIndices.put(cell.getStringCellValue(), cell.getColumnIndex());
}

def rowCount = sheet.getPhysicalNumberOfRows();

// Initialize assertionFailed flag for overall comparison
def assertionFailed = false;
def mismatchMessages = new StringBuilder();

// Loop through the rows in the Excel sheet
for (int rowIndex = 1; rowIndex &lt; rowCount; rowIndex++) {
    Row dataRow = sheet.getRow(rowIndex);
    if (dataRow == null) {
        continue; // Skip empty rows
    }

    // Get Seq No and PrimaryIndex from the current row
    Cell seqNoCell = dataRow.getCell(columnIndices.get(&quot;Seq No&quot;));
    Cell PrimaryIndexCell = dataRow.getCell(columnIndices.get(&quot;PrimaryIndex&quot;));
    
    if (seqNoCell == null || PrimaryIndexCell == null) {
        continue; // Skip rows where Seq No or PrimaryIndex is missing
    }
    
    int seqNo = (int) seqNoCell.getNumericCellValue();
    int PrimaryIndex = (int) PrimaryIndexCell.getNumericCellValue();

    // Get the JSON data for the current Seq No
    def jsonDataVar = &quot;LIFEPRO_MAPPINGS_&quot; + seqNo;
    def jsonData = vars.get(jsonDataVar);
    log.info(&quot;Database JSON data for Seq No ${seqNo}: ${jsonData}&quot;);

    def databaseJson;
    try {
        databaseJson = new JsonSlurper().parseText(jsonData);
    } catch (Exception e) {
        log.error(&quot;Failed to parse JSON data: ${e.message}&quot;);
        continue; // Skip to the next row
    }

    // Convert numeric values to integers
    def dbData = [
        &quot;FormatCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.FormatCode,
        &quot;Last&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.Last,
        &quot;First&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.First,
        &quot;Middle&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.Middle,
        &quot;SubTypeCode&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.SubTypeCode,
        &quot;PercentOfInterest&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.PercentOfInterest,
        &quot;AmountOfInterest&quot;: databaseJson?.lifeproLogs?.newBusinessRequest?.newBusinessRequest?.PrimaryBeneficiariesName?[PrimaryIndex]?.AmountOfInterest,
    ];

    dbData = dbData.collectEntries { key, value -&gt;
        [key, value instanceof BigDecimal ? value.intValue() : value]
    }

    log.info(&quot;Benefits Data: ${dbData}&quot;);

    // Read data from the current row in the Excel sheet
    Map&lt;String, String&gt; excelData = new HashMap&lt;&gt;();
    for (String column : dbData.keySet()) {
        Cell cell = dataRow.getCell(columnIndices.get(column));
        if (cell != null) {
            switch (cell.getCellType()) {
                case CellType.STRING:
                    excelData.put(column, cell.getStringCellValue().trim());
                    break;
                case CellType.NUMERIC:
                    double numericValue = cell.getNumericCellValue();
                    // Check if the value is a whole number
                    if (numericValue == Math.floor(numericValue)) {
                        // If it&apos;s a whole number, convert it to integer and then to string
                        excelData.put(column, String.valueOf((int) numericValue));
                    } else {
                        // If it has a decimal part, ignore it
                        excelData.put(column, &quot;&quot;); // Or any other logic as per your requirement
                    }
                    break;
                case CellType.BLANK:
                    excelData.put(column, &quot;&quot;); // Treat blank cells as empty string
                    break;
                default:
                    excelData.put(column, &quot;null&quot;); // Treat other types as null
            }
        } else {
            excelData.put(column, &quot;&quot;); // Treat null cells as empty string
        }
    }

    // Remove nameId from dbData and excelData before comparison
    dbData.remove(&quot;nameId&quot;);
    excelData.remove(&quot;nameId&quot;);

    // Compare JSON data from the database with data from Excel
    def rowMismatch = false;
    for (String key : dbData.keySet()) {
        def dbValue = dbData.get(key)?.toString() ?: &quot;&quot;;
        def excelValue = excelData.get(key);

        // Compare values
        if (!dbValue.equals(excelValue)) {
            rowMismatch = true;
            assertionFailed = true;
            mismatchMessages.append(&quot;Mismatch found for Seq No ${seqNo}, PrimaryIndex ${PrimaryIndex}, &apos;${key}&apos;: database=&apos;${dbValue}&apos;, excel=&apos;${excelValue}&apos;\n&quot;);
        }
    }

    if (!rowMismatch) {
        log.info(&quot;All data from the database matches the data from the Excel sheet for Seq No ${seqNo}, PrimaryIndex ${PrimaryIndex}&quot;);
    }
}

workbook.close();
fileStream.close();

// Output the assertions
if (assertionFailed) {
    // Fail the assertion
    AssertionResult.setFailure(true);
    AssertionResult.setFailureMessage(&quot;Mismatch found between database and Excel data:\n${mismatchMessages.toString()}&quot;);
} else {
    log.info(&quot;All data from the database matches the data from the Excel sheet&quot;);
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
              <stringProp name="ConstantTimer.delay">5000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from Worksite DOCUMENTS, File Name: ${inputFileName}" enabled="true">
            <stringProp name="dataSource">AFBADatabase</stringProp>
            <stringProp name="query">SELECT DOCUMENT_TYPE, DOCUMENT_EXTENSION FROM WORKSITE_DOCUMENT WHERE DOCUMENT_ID = &apos;${DOCUMENT_ID_1}&apos;</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames">DOCUMENT_TYPE, DOCUMENT_EXTENSION</stringProp>
          </JDBCSampler>
          <hashTree>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion TYPE, EXTENSION Worksite DOCUMENTS" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def DOCUMENT_TYPE_1 = &apos;${DOCUMENT_TYPE_1}&apos;
def DOCUMENT_EXTENSION_1 = &apos;${DOCUMENT_EXTENSION_1}&apos;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Worksite_Documents&quot; sheet
    def worksiteDocumentsSheet = workbook.getSheet(&quot;Worksite_Documents&quot;)
    if (worksiteDocumentsSheet != null) {
        log.info(&quot;Processing data from sheet: Worksite_Documents&quot;)
        processSheet(worksiteDocumentsSheet, DOCUMENT_TYPE_1, DOCUMENT_EXTENSION_1, assertionList)
    } else {
        log.info(&quot;Sheet Worksite_Documents not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, DOCUMENT_TYPE_1, DOCUMENT_EXTENSION_1, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume DOCUMENT_TYPE and DOCUMENT_EXTENSION columns exist
    def documentTypeColumnIndex = headers.indexOf(&quot;DOCUMENT_TYPE&quot;)
    def documentExtensionColumnIndex = headers.indexOf(&quot;DOCUMENT_EXTENSION&quot;)

    // Process rows starting from the second row
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)
        def documentTypeCell = row.getCell(documentTypeColumnIndex)
        def documentExtensionCell = row.getCell(documentExtensionColumnIndex)

        def documentType = documentTypeCell?.getStringCellValue()?.trim()
        def documentExtension = documentExtensionCell?.getStringCellValue()?.trim()

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: Worksite_Documents Document Type from Excel: ${documentType}, Expected DOCUMENT_TYPE_1: ${DOCUMENT_TYPE_1}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Worksite_Documents Document Extension from Excel: ${documentExtension}, Expected DOCUMENT_EXTENSION_1: ${DOCUMENT_EXTENSION_1}&quot;)

        // Check if values do not match expected values
        if (documentType != DOCUMENT_TYPE_1) {
            assertionList.add(&quot;Worksite_Documents Document Type in row ${rowIndex + 1} does not match expected value: $documentType&quot;)
        }

        if (documentExtension != DOCUMENT_EXTENSION_1) {
            assertionList.add(&quot;Worksite_Documents Document Extension in row ${rowIndex + 1} does not match expected value: $documentExtension&quot;)
        }
    }
}

</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
              <stringProp name="ConstantTimer.delay">5000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from Worksite Policy Metadata, File Name: ${inputFileName}" enabled="true">
            <stringProp name="dataSource">AFBADatabase</stringProp>
            <stringProp name="query">SELECT INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME FROM WORKSITE_POLICY_METADATA WHERE POLICY_NUMBER = &apos;${POLICY_NUMBER_1}&apos;</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames">INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME</stringProp>
          </JDBCSampler>
          <hashTree>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME Worksite POLICY_Metadata" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile
import org.apache.poi.ss.usermodel.DateUtil
import org.apache.poi.ss.util.NumberToTextConverter

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def INSURED_SSN = &apos;${INSURED_SSN_1}&apos;.replaceAll(&quot;^0+&quot;, &quot;&quot;) // Remove leading zeros
def INSURED_LAST_NAME = &apos;${INSURED_LAST_NAME_1}&apos;
def INSURED_FIRST_NAME = &apos;${INSURED_FIRST_NAME_1}&apos;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Policy_Metadata&quot; sheet
    def worksiteDocumentsSheet = workbook.getSheet(&quot;Policy_Metadata&quot;)
    if (worksiteDocumentsSheet != null) {
        log.info(&quot;Processing data from sheet: Policy_Metadata&quot;)
        processSheet(worksiteDocumentsSheet, INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME, assertionList)
    } else {
        log.info(&quot;Sheet Policy_Metadata not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume INSURED_SSN, INSURED_LAST_NAME, INSURED_FIRST_NAME columns exist
    def ssnColumnIndex = headers.indexOf(&quot;INSURED_SSN&quot;)
    def lastNameColumnIndex = headers.indexOf(&quot;INSURED_LAST_NAME&quot;)
    def firstNameColumnIndex = headers.indexOf(&quot;INSURED_FIRST_NAME&quot;)

    // Process rows starting from the second row
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)
        def ssnCell = row.getCell(ssnColumnIndex)
        def lastNameCell = row.getCell(lastNameColumnIndex)
        def firstNameCell = row.getCell(firstNameColumnIndex)

        // Handle numeric cells
        def ssn = getCellValueAsString(ssnCell)
        def lastName = getCellValueAsString(lastNameCell)
        def firstName = getCellValueAsString(firstNameCell)

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: INSURED_SSN from Excel: ${ssn}, Expected INSURED_SSN: ${INSURED_SSN}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: INSURED_LAST_NAME from Excel: ${lastName}, Expected INSURED_LAST_NAME: ${INSURED_LAST_NAME}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: INSURED_FIRST_NAME from Excel: ${firstName}, Expected INSURED_FIRST_NAME: ${INSURED_FIRST_NAME}&quot;)

        // Check if values do not match expected values
        if (ssn != INSURED_SSN) {
            assertionList.add(&quot;INSURED_SSN in row ${rowIndex + 1} does not match expected value: $ssn&quot;)
        }

        if (lastName != INSURED_LAST_NAME) {
            assertionList.add(&quot;INSURED_LAST_NAME in row ${rowIndex + 1} does not match expected value: $lastName&quot;)
        }

        if (firstName != INSURED_FIRST_NAME) {
            assertionList.add(&quot;INSURED_FIRST_NAME in row ${rowIndex + 1} does not match expected value: $firstName&quot;)
        }
    }
}

def getCellValueAsString(cell) {
    if (cell) {
        if (cell.getCellType() == CellType.NUMERIC) {
            // Check if the numeric value is actually a date
            if (DateUtil.isCellDateFormatted(cell)) {
                // Convert date to string
                return cell.getDateCellValue().toString()
            } else {
                // Convert numeric value to string and trim leading zeros
                return NumberToTextConverter.toText(cell.getNumericCellValue()).replaceAll(&quot;^0+&quot;, &quot;&quot;)
            }
        } else {
            // For other types, retrieve as string directly
            return cell.getStringCellValue()?.trim()
        }
    }
    return null
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
              <stringProp name="ConstantTimer.delay">5000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller checking Change File, File Name: ${inputFileName}" enabled="true">
            <stringProp name="IfController.condition">${__groovy(vars.get(&quot;inputFileName&quot;).contains(&quot;Change&quot;))}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler Enrollment Size Count" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="script">import java.util.Arrays;

// Initialize a StringBuilder to concatenate all enrollment IDs
StringBuilder enrollmentIdsBuilder = new StringBuilder();

// Get the count of enrollment ID variables
int count = 1; 
while (vars.get(&quot;ENROLLMENT_ID_&quot; + count) != null) {
    // Append the enrollment ID to the StringBuilder
    enrollmentIdsBuilder.append(vars.get(&quot;ENROLLMENT_ID_&quot; + count));

    // Append a comma if it&apos;s not the last enrollment ID
    if (vars.get(&quot;ENROLLMENT_ID_&quot; + (count + 1)) != null) {
        enrollmentIdsBuilder.append(&quot;,&quot;);
    }

    count++; // Move to the next variable
}

// Convert the StringBuilder to a String
String enrollmentIds = enrollmentIdsBuilder.toString();

// Split the enrollment IDs by comma to count the number of elements
String[] enrollmentIdArray = enrollmentIds.split(&quot;,&quot;);
int size = enrollmentIdArray.length;

// Print the size of the enrollment ID array to JMeter log
log.info(&quot;Size of enrollment ID array: &quot; + size);

// Set the size as a JMeter variable for further use if needed
vars.put(&quot;ENROLLMENT_ID_SIZE&quot;, String.valueOf(size));



</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="LoopControllerEnrollmentID" enabled="true">
              <boolProp name="LoopController.continue_forever">true</boolProp>
              <stringProp name="LoopController.loops">${ENROLLMENT_ID_SIZE}</stringProp>
            </LoopController>
            <hashTree>
              <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                <collectionProp name="UserParameters.names">
                  <stringProp name="-318302350">SetStartIndex</stringProp>
                </collectionProp>
                <collectionProp name="UserParameters.thread_values">
                  <collectionProp name="1522015871">
                    <stringProp name="190129256">${__intSum(${__jm__LoopControllerEnrollmentID__idx},1,startIdx)}</stringProp>
                  </collectionProp>
                </collectionProp>
                <boolProp name="UserParameters.per_iteration">false</boolProp>
              </UserParameters>
              <hashTree/>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from Worksite TASK, File Name: ${inputFileName}" enabled="true">
                <stringProp name="dataSource">AFBADatabase</stringProp>
                <stringProp name="query">SELECT QUEUE_ID 
FROM WORKSITE_TASK 
WHERE ENROLLMENT_ID = &apos;${__V(ENROLLMENT_ID_${startIdx},)}&apos;;
</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">QUEUE_ID</stringProp>
              </JDBCSampler>
              <hashTree>
                <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion QUEUE_ID Worksite TASK" enabled="true">
                  <stringProp name="cacheKey">false</stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Worksite_Task&quot; sheet
    def taskSheet = workbook.getSheet(&quot;Worksite_Task&quot;)
    if (taskSheet != null) {
        log.info(&quot;Processing data from sheet: Worksite_Task&quot;)
        
        // Adjust loop iteration index
        def loopIndex = ${__jm__LoopControllerEnrollmentID__idx}
        processSheet(taskSheet, loopIndex, assertionList)
    } else {
        log.info(&quot;Sheet Worksite_Task not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, loopIndex, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume QUEUE_ID column exists
    def queueIdColumnIndex = headers.indexOf(&quot;QUEUE_ID&quot;)

    // Process the row for the current loop iteration
    def rowIndex = loopIndex + 1
    if (rowIndex &gt;= 1 &amp;&amp; rowIndex &lt;= sheet.getLastRowNum()) {
        def row = sheet.getRow(rowIndex)

        // Get value from the Excel sheet for the current iteration
        def queueIdCell = row.getCell(queueIdColumnIndex)

        // Handle null values or empty strings in Excel sheet
        def queueId
        if (queueIdCell != null) {
            if (queueIdCell.cellType == CellType.NUMERIC) {
                queueId = queueIdCell.getNumericCellValue().toInteger().toString()
            } else {
                queueId = queueIdCell.getStringCellValue().trim()
            }
        } else {
            queueId = null
        }

        // Log values being compared
        log.info(&quot;Row ${rowIndex}: Worksite_Task QUEUE_ID from Excel: ${queueId}&quot;)
        
        // Compare the value from Excel with dynamically updated DB value
        def dbQueueId = vars.get(&quot;QUEUE_ID_1&quot;)
        
        // Log value being compared with DB
        log.info(&quot;Row ${rowIndex}: DB QUEUE_ID: ${dbQueueId}&quot;)
        
        // Check if values do not match expected values
        if (queueId != dbQueueId) {
            assertionList.add(&quot;Worksite_Task QUEUE_ID in row ${rowIndex} does not match expected value: ${queueId} (Excel) vs ${dbQueueId} (DB)&quot;)
        }
    } else {
        log.info(&quot;No more rows to process&quot;)
    }
}
</stringProp>
                  <stringProp name="scriptLanguage">groovy</stringProp>
                </JSR223Assertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from Worksite DOCUMENTS, File Name: ${inputFileName}" enabled="true">
              <stringProp name="dataSource">AFBADatabase</stringProp>
              <stringProp name="query">SELECT DOCUMENT_TYPE, DOCUMENT_EXTENSION FROM WORKSITE_DOCUMENT WHERE DOCUMENT_ID = &apos;${DOCUMENT_ID_1}&apos;</stringProp>
              <stringProp name="queryArguments"></stringProp>
              <stringProp name="queryArgumentsTypes"></stringProp>
              <stringProp name="queryTimeout"></stringProp>
              <stringProp name="queryType">Select Statement</stringProp>
              <stringProp name="resultSetHandler">Store as String</stringProp>
              <stringProp name="resultSetMaxRows"></stringProp>
              <stringProp name="resultVariable"></stringProp>
              <stringProp name="variableNames">DOCUMENT_TYPE, DOCUMENT_EXTENSION</stringProp>
            </JDBCSampler>
            <hashTree>
              <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion TYPE, EXTENSION Worksite DOCUMENTS" enabled="true">
                <stringProp name="cacheKey">false</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def DOCUMENT_TYPE_1 = &apos;${DOCUMENT_TYPE_1}&apos;
def DOCUMENT_EXTENSION_1 = &apos;${DOCUMENT_EXTENSION_1}&apos;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Worksite_Documents&quot; sheet
    def worksiteDocumentsSheet = workbook.getSheet(&quot;Worksite_Documents&quot;)
    if (worksiteDocumentsSheet != null) {
        log.info(&quot;Processing data from sheet: Worksite_Documents&quot;)
        processSheet(worksiteDocumentsSheet, DOCUMENT_TYPE_1, DOCUMENT_EXTENSION_1, assertionList)
    } else {
        log.info(&quot;Sheet Worksite_Documents not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, DOCUMENT_TYPE_1, DOCUMENT_EXTENSION_1, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume DOCUMENT_TYPE and DOCUMENT_EXTENSION columns exist
    def documentTypeColumnIndex = headers.indexOf(&quot;DOCUMENT_TYPE&quot;)
    def documentExtensionColumnIndex = headers.indexOf(&quot;DOCUMENT_EXTENSION&quot;)

    // Process rows starting from the second row
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)
        def documentTypeCell = row.getCell(documentTypeColumnIndex)
        def documentExtensionCell = row.getCell(documentExtensionColumnIndex)

        def documentType = documentTypeCell?.getStringCellValue()?.trim()
        def documentExtension = documentExtensionCell?.getStringCellValue()?.trim()

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: Worksite_Documents Document Type from Excel: ${documentType}, Expected DOCUMENT_TYPE_1: ${DOCUMENT_TYPE_1}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Worksite_Documents Document Extension from Excel: ${documentExtension}, Expected DOCUMENT_EXTENSION_1: ${DOCUMENT_EXTENSION_1}&quot;)

        // Check if values do not match expected values
        if (documentType != DOCUMENT_TYPE_1) {
            assertionList.add(&quot;Worksite_Documents Document Type in row ${rowIndex + 1} does not match expected value: $documentType&quot;)
        }

        if (documentExtension != DOCUMENT_EXTENSION_1) {
            assertionList.add(&quot;Worksite_Documents Document Extension in row ${rowIndex + 1} does not match expected value: $documentExtension&quot;)
        }
    }
}

</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223Assertion>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Field Validations" enabled="true"/>
        <hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get data from ENROLLMENT, WORKSITE_WARNING File Name: ${inputFileName}" enabled="true">
            <stringProp name="dataSource">AFBADatabase</stringProp>
            <stringProp name="query">SELECT w.WARNING_TEXT, e.FAILURE_REASON ,  e.STATUS , e.ENROLLMENT_ID
FROM ENROLLMENT e 
full JOIN WORKSITE_WARNING w ON w.ENROLLMENT_ID = e.ENROLLMENT_ID 
where e.FILE_ID = &apos;${FILE_ID_1}&apos;</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames">WARNING_TEXT, FAILURE_REASON, STATUS, ENROLLMENT_ID</stringProp>
          </JDBCSampler>
          <hashTree>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 Assertion WARNING_TEXT, STATUS, FAILURE_REASON Enrollment" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.io.FileInputStream
import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.openxml4j.util.ZipSecureFile

// Initialize assertion list
def assertionList = []

def folderPath = &quot;${__P(outputLocation)}&quot;
def fileName = &apos;${outputFileName}&apos;
def targetSubfolder = &quot;SFTPResults&quot;
def fullPath = &quot;${folderPath}/${targetSubfolder}/${fileName}&quot;

def inStream = new FileInputStream(fullPath)

try {
    ZipSecureFile.setMinInflateRatio(0)
    def workbook = new XSSFWorkbook(inStream)

    // Process the &quot;Field_Validation&quot; sheet
    def fieldValidationSheet = workbook.getSheet(&quot;Field_Validation&quot;)
    if (fieldValidationSheet != null) {
        log.info(&quot;Processing data from sheet: Field_Validation&quot;)
        processSheet(fieldValidationSheet, assertionList)
    } else {
        log.info(&quot;Sheet Field_Validation not found&quot;)
    }

} catch (Exception e) {
    log.error(&quot;Error occurred: {}&quot;, e.toString())
    assertionList.add(&quot;Error occurred: ${e.toString()}&quot;)
} finally {
    inStream.close()
}

// Throw assertion error if any assertion failed
if (!assertionList.empty) {
    def errorMessage = &quot;Assertion failure:\n&quot;
    assertionList.eachWithIndex { error, index -&gt;
        errorMessage += &quot;${index + 1}. $error\n&quot;
    }
    throw new AssertionError(errorMessage)
}

def processSheet(sheet, assertionList) {
    def headerRow = sheet.getRow(0)
    def headers = []
    for (int j = 0; j &lt; headerRow.physicalNumberOfCells; j++) {
        def headerCell = headerRow.getCell(j)
        def header = headerCell.getStringCellValue().trim()
        headers.add(header)
    }

    // Assume STATUS, FAILURE_REASON, and WARNING_TEXT columns exist
    def statusColumnIndex = headers.indexOf(&quot;STATUS&quot;)
    def failureReasonColumnIndex = headers.indexOf(&quot;FAILURE_REASON&quot;)
    def warningTextColumnIndex = headers.indexOf(&quot;WARNING_TEXT&quot;)

    // Process each row dynamically
    for (int rowIndex = 1; rowIndex &lt;= sheet.getLastRowNum(); rowIndex++) {
        def row = sheet.getRow(rowIndex)

        // Adjust expected statuses, failure reasons, and warning texts dynamically
        def expectedStatus = vars.get(&quot;STATUS_${rowIndex}&quot;)
        def expectedFailureReason = vars.get(&quot;FAILURE_REASON_${rowIndex}&quot;)
        def expectedWarningText = vars.get(&quot;WARNING_TEXT_${rowIndex}&quot;)

        def enrollmentStatusCell = row.getCell(statusColumnIndex)
        def enrollmentFailureReasonCell = row.getCell(failureReasonColumnIndex)
        def enrollmentWarningTextCell = row.getCell(warningTextColumnIndex)

        // Handle null values or empty strings in Excel sheet
        def enrollmentStatus = enrollmentStatusCell?.getStringCellValue()?.trim() ?: &quot;&quot;
        def enrollmentFailureReason = enrollmentFailureReasonCell?.getStringCellValue()?.trim() ?: &quot;&quot;
        def enrollmentWarningText = enrollmentWarningTextCell?.getStringCellValue()?.trim() ?: &quot;&quot;

        // Treat both null values and empty strings as equivalent
        if (enrollmentFailureReason == &quot;null&quot; || enrollmentFailureReason.isEmpty()) {
            enrollmentFailureReason = null
        }

        if (enrollmentWarningText == &quot;null&quot; || enrollmentWarningText.isEmpty()) {
            enrollmentWarningText = null
        }

        // Log values being compared
        log.info(&quot;Row ${rowIndex + 1}: Enrollment Status from Excel: ${enrollmentStatus}, Expected: ${expectedStatus}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Enrollment Failure Reason from Excel: ${enrollmentFailureReason}, Expected: ${expectedFailureReason}&quot;)
        log.info(&quot;Row ${rowIndex + 1}: Enrollment Warning Text from Excel: ${enrollmentWarningText}, Expected: ${expectedWarningText}&quot;)

        // Check if values do not match expected values
        if (enrollmentStatus != expectedStatus) {
            assertionList.add(&quot;Enrollment Status in row ${rowIndex + 1} does not match expected value: $enrollmentStatus&quot;)
        }

        if (enrollmentFailureReason != expectedFailureReason) {
            assertionList.add(&quot;Enrollment Failure Reason in row ${rowIndex + 1} does not match expected value: $enrollmentFailureReason&quot;)
        }

        if (enrollmentWarningText != expectedWarningText) {
            assertionList.add(&quot;Enrollment Warning Text in row ${rowIndex + 1} does not match expected value: $enrollmentWarningText&quot;)
        }
    }
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="SimpleDataWriter" testclass="ResultCollector" testname="Simple Data Writer" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">ExecutionResults.csv</stringProp>
        </ResultCollector>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler Creating the HTML Report" enabled="false">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">false</stringProp>
          <stringProp name="script">import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

    public static void main(String[] args) {
        String csvFile = &quot;ExecutionResults.csv&quot;;
        String passOutputFile = &quot;PassReport.html&quot;;
        String failOutputFile = &quot;FailReport.html&quot;;

        List&lt;Map&lt;String, String&gt;&gt; data = new ArrayList&lt;&gt;();

        try (CSVReader reader = new CSVReader(new FileReader(csvFile))) {
            String[] headers = reader.readNext();
            String[] row;

            while ((row = reader.readNext()) != null) {
                Map&lt;String, String&gt; rowData = new LinkedHashMap&lt;&gt;();
                for (int i = 0; i &lt; headers.length; i++) {
                    if (i &lt; row.length) {
                        rowData.put(headers[i], row[i]);
                    } else {
                        rowData.put(headers[i], &quot;&quot;); // Handle missing values
                    }
                }
                data.add(rowData);
            }
        } catch (IOException | CsvValidationException e) {
            e.printStackTrace();
        }

        // Separate pass and fail data
        List&lt;Map&lt;String, String&gt;&gt; passData = new ArrayList&lt;&gt;();
        List&lt;Map&lt;String, String&gt;&gt; failData = new ArrayList&lt;&gt;();

        for (Map&lt;String, String&gt; row : data) {
            String success = row.get(&quot;success&quot;);
            if (success != null &amp;&amp; success.equalsIgnoreCase(&quot;false&quot;)) {
                failData.add(row);
            } else {
                passData.add(row);
            }
        }

        // Generate the pass and fail reports
        generateReport(passData, passOutputFile);
        generateReport(failData, failOutputFile);
    }

    public static void generateReport(List&lt;Map&lt;String, String&gt;&gt; data, String outputFile) {
        StringBuilder report = new StringBuilder();
        int passCount = 0;
        int failCount = 0;

        for (Map&lt;String, String&gt; row : data) {
            String success = row.get(&quot;success&quot;);

            if (success != null &amp;&amp; success.equalsIgnoreCase(&quot;false&quot;)) {
                failCount++;
            } else {
                passCount++;
            }
        }
report.append(&quot;&lt;!DOCTYPE html&gt;\n&quot;)
    .append(&quot;&lt;html&gt;\n&quot;)
    .append(&quot;&lt;head&gt;\n&quot;)
    .append(&quot;    &lt;title&gt;API Functional Test Report&lt;/title&gt;\n&quot;)
    .append(&quot;    &lt;style&gt;\n&quot;)
    .append(&quot;        body {\n&quot;)
    .append(&quot;            font-family: Arial, sans-serif;\n&quot;)
    .append(&quot;            margin: 20px;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        h1 {\n&quot;)
    .append(&quot;            color: #333;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case {\n&quot;)
    .append(&quot;            margin-bottom: 30px;\n&quot;)
    .append(&quot;            border: 1px solid #ccc;\n&quot;)
    .append(&quot;            padding: 10px;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case h2 {\n&quot;)
    .append(&quot;            color: #666;\n&quot;)
    .append(&quot;            margin-top: 0;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case .request {\n&quot;)
    .append(&quot;            margin-bottom: 15px;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case .response {\n&quot;)
    .append(&quot;            margin-bottom: 15px;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case .response pre {\n&quot;)
    .append(&quot;            background-color: #f2f2f2;\n&quot;)
    .append(&quot;            padding: 10px;\n&quot;)
    .append(&quot;            overflow-x: auto;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case .status-pass {\n&quot;)
    .append(&quot;            color: green;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;        .test-case .status-fail {\n&quot;)
    .append(&quot;            color: red;\n&quot;)
    .append(&quot;        }\n&quot;)
    .append(&quot;    &lt;/style&gt;\n&quot;)
    .append(&quot;&lt;/head&gt;\n&quot;)
    .append(&quot;&lt;body&gt;\n&quot;)
    .append(&quot;    &lt;h1&gt;API Functional Test Report&lt;/h1&gt;\n&quot;)
    .append(&quot;    &lt;h2&gt;Summary:&lt;/h2&gt;\n&quot;)
    .append(&quot;    &lt;p&gt;Total Cases: &quot;).append(data.size()).append(&quot;&lt;/p&gt;\n&quot;)
    .append(&quot;    &lt;p class=\&quot;status-pass\&quot;&gt;Total Pass: &quot;).append(passCount).append(&quot;&lt;/p&gt;\n&quot;)
    .append(&quot;    &lt;p class=\&quot;status-fail\&quot;&gt;Total Fail: &quot;).append(failCount).append(&quot;&lt;/p&gt;\n&quot;);

for (Map&lt;String, String&gt; row : data) {
    String label = row.get(&quot;label&quot;);
    String responseMessage = row.get(&quot;responseMessage&quot;);
    String success = row.get(&quot;success&quot;);
    String failureMessage = row.get(&quot;failureMessage&quot;);

    report.append(&quot;&lt;div class=\&quot;test-case\&quot;&gt;\n&quot;)
        .append(&quot;    &lt;h2&gt;&quot;).append(label).append(&quot;&lt;/h2&gt;\n&quot;)
        .append(&quot;    &lt;div class=\&quot;request\&quot;&gt;\n&quot;)
        .append(&quot;        &lt;h3&gt;Request:&lt;/h3&gt;\n&quot;)
        .append(&quot;        &lt;pre&gt;&quot;).append(responseMessage).append(&quot;&lt;/pre&gt;\n&quot;)
        .append(&quot;    &lt;/div&gt;\n&quot;)
        .append(&quot;    &lt;div class=\&quot;response\&quot;&gt;\n&quot;);

    if (success != null &amp;&amp; success.equalsIgnoreCase(&quot;false&quot;)) {
        report.append(&quot;        &lt;p class=\&quot;status-fail\&quot;&gt;Status: &quot;).append(success)
            .append(&quot;&lt;/p&gt;\n&quot;)
            .append(&quot;        &lt;pre&gt;&quot;).append(failureMessage).append(&quot;&lt;/pre&gt;\n&quot;);
    } else {
        report.append(&quot;        &lt;p class=\&quot;status-pass\&quot;&gt;Status: &quot;).append(success).append(&quot;&lt;/p&gt;\n&quot;);
    }

    report.append(&quot;    &lt;/div&gt;\n&quot;)
        .append(&quot;&lt;/div&gt;\n&quot;);
}

report.append(&quot;&lt;/body&gt;\n&quot;)
    .append(&quot;&lt;/html&gt;&quot;);


        // Write the report to the output file
        try (FileWriter writer = new FileWriter(outputFile)) {
            writer.write(report.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;Report generated successfully.&quot;);
        System.out.println(&quot;Total Cases: &quot; + data.size());
    }</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">final-report-missing-fields.csv</stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
